##LANGUAGE 'C#'
##TEMPLATE-NAME 'Edit free parser class'
##ENGINE-NAME 'Frengine'
##SYSTEM-VERSION '5.0'
##AUTHOR 'Omar Pakker' 
##FILE-EXTENSION 'cs'
##NOTES
This template creates the parser file
in such a way that no edits to the file
are required. Instead, you should extend
from it and work from there. This allows
for regeneration without losing custom code.
##END-NOTES
##ID-CASE ProperCase
##ID-SEPARATOR '_'
##DELIMITER ','
##PARAMETERS
/*
 * Grammar Information:
 *
 * Name            : %Name%
 * Version         : %Version%
 * Author          : %Author%
 * About           : %About%
 * Case Sensitive  : %CaseSensitive%
 * Start Symbol    : %StartSymbol%
 *
 *
 * Grammar Build Information:
 *
 * Output File Path : %OutputFilePath%
 * Output Path      : %OutputPath%
 * Output File      : %OutputFile%
 * Output File Base : %OutputFileBase%
 *
##END-PARAMETERS
##SYMBOL-TABLE
 * Symbol Count : %Count%
##END-SYMBOL-TABLE
##RULE-TABLE
 * Rule Count   : %Count%
##END-RULE-TABLE
 */
using System.IO;
using GOLD;

namespace com.OPCreations.GoldParser
{
	public enum SymbolIndex
    {
##SYMBOLS
        @%ID% = %Value%%Delimiter% %Col:50% // %Description%
##END-SYMBOLS
    };

    public enum RuleIndex
    {
##RULES
        @%ID% = %Value%%Delimiter% %Col:50% // %Description%
##END-RULES
    };

	public abstract class BaseParser
	{
		private Parser parser;

		protected Position ParserPosition { get { return parser.CurrentPosition(); } }

		public BaseParser(bool trimReductions)
		{
			parser = new GOLD.Parser();
			parser.TrimReductions = trimReductions;
		}

		protected bool LoadGrammar(string grammarFilePath)
		{
			return parser.LoadTables(grammarFilePath);
		}

		protected bool LoadGrammar(BinaryReader reader)
		{
			return parser.LoadTables(reader);
		}

		public bool Parse(string text)
		{
			parser.Open(ref text);
			
			return DoParse();
		}

		public bool Parse(TextReader reader)
		{
			parser.Open(reader);

			return DoParse();
		}

		private bool DoParse()
		{
			while (true)
			{
				switch (parser.Parse())
				{
					case ParseMessage.TokenRead:
						break;

					case ParseMessage.Reduction:
						//Create a custom object and store the reduction
						parser.CurrentReduction = OnReduction(parser.CurrentReduction as Reduction);
						break;

					case ParseMessage.Accept:
						//All good!
						OnCompletion(parser.CurrentReduction);
                        return true;

					case ParseMessage.GroupError:
						//Unexpected end of file (EOF)
						OnGroupError();
                        return false;

					case ParseMessage.InternalError:
						//Something went wrong internally
						OnInternalError();
                        return false;

					case ParseMessage.LexicalError:
						//Token not recognized
						OnLexicalError(parser.CurrentPosition().Line, parser.CurrentPosition().Column, parser.CurrentToken().Data);
                        return false;

					case ParseMessage.NotLoadedError:
						//CGT wasn't loaded
						OnNotLoadedError();
                        return false;

					case ParseMessage.SyntaxError:
						//Expected a different token
						OnSyntaxError(parser.CurrentPosition().Line, parser.CurrentPosition().Column,
							parser.CurrentToken().Data, parser.ExpectedSymbols().Text());
                        return false;
				}
			}
		}

		protected abstract object OnReduction(Reduction r);
		protected abstract void OnCompletion(object root);

		protected abstract void OnGroupError();
		protected abstract void OnInternalError();
		protected abstract void OnNotLoadedError();
		protected abstract void OnLexicalError(int line, int column, object token);
		protected abstract void OnSyntaxError(int line, int column, object token, string expected);
	}
}



/*
 * Pre-build switch covering all the rules
 */
#region Rules Switch
//switch((RuleIndex)r.Parent.TableIndex())
//{
##RULES
//	case RuleIndex.%ID%:
//		// %Description%
//		break;
//
##END-RULES
//}
#endregion
