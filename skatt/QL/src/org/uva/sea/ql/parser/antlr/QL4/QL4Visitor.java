package org.uva.sea.ql.parser.antlr.QL4;

import java.util.ArrayList;
import java.util.List;

import org.uva.sea.ql.parser.antlr.QL4.AST.*;
import org.uva.sea.ql.parser.antlr.QL4.AST.Expression.QLExpression;

import QL4.QL4BaseVisitor;
import QL4.QL4Parser;

/**
 * A visitor for the QL4 grammar. Visits a tree parsed by the Antlr4
 * generated QL4parser on the QL4 grammar. Extends the QL4BaseVisitor
 * generated by Antrl4 and implements any function that needs
 * a more sophisticated visit  than depth first
 * @author Sammie Katt
 *
 */
public class QL4Visitor extends QL4BaseVisitor<QLTree> {

  // Handles the information printed
  boolean verbose = true;

  /**
   * Specifies behavior when visiting the form 
   * it will simply visit its structures and return the tree
   * generated throughout the visiting process
   * 
   * @param ctx is the context of the structures
   * @return the generated tree by visiting its childs
   */
  public QLTree visitForm(QL4Parser.FormContext ctx) {
	  if (verbose) 
	      System.out.println("Visiting Form");
	
	  return new QL4Form(ctx.structures().accept(this));
  }
  
  /**
   * Returns a structures object, containing its structure in a list
   * 
   * @param ctx is the structures context from which structure(s) are extracted
   * @return the structures object
   */
  public QLTree visitStructures(QL4Parser.StructuresContext ctx) {
	  if (verbose)
		  System.out.println("Visiting structures");
		  
	  List<QLTree> structures = new ArrayList<QLTree>();
	  
	  for (QL4Parser.StructureContext struct : ctx.structure()) {
		  structures.add(struct.accept(this));
	  }
	  
	  return new QL4Structures(structures);
  }

  /**
   * Returns a conditional object containing  
   * @param ctx the conditional context
   * @return a conditional object 
   */
  public QLTree visitConditional(QL4Parser.ConditionalContext ctx) {
	 if (verbose)  
		 System.out.println("Visiting conditional");
	 
	 // define if/else (if available) conditions
	 QLTree ifCondition = ctx.ifcondition().accept(this);
	 QLTree elseCondition = null;
	 
	 if (ctx.elsecondition() != null) {
		 elseCondition = ctx.elsecondition().accept(this);
	 } 
	 
	 // define structures TODO: name them in grammar such that we can call them and actually call them
	 
	 // define elseifConditions and their structs by looping over them in ctx
	 List<QLTree> elseifConditions = new ArrayList<QLTree>();
	 
	 for (QL4Parser.ElseifconditionContext elseif : ctx.elseifcondition()) {
		 elseifConditions.add(elseif.accept(this));
	 }
	 
	 return new QL4Conditional(ifCondition, elseCondition, elseifConditions);
  }
  
  /**
   * Returns a question object, containing its content:
   * Type, label, id and value
   * @param ctx
   * @return
   */
  public QLTree visitRegQuestion(QL4Parser.RegQuestionContext ctx) {
	  if (verbose) 
		  System.out.println("Visiting RegQuestion");
	  
	  QLTree id = ctx.IDENTIFIER().accept(this);
	  QLTree label = ctx.LABEL().accept(this);
	  QLTree type = ctx.TYPE().accept(this);
	  
	  return new QL4RegQuestion(id, label, type); 
  }
  
  /**
   * Returns a compQuestion object, containing its content:
   * Type, label, id and value
   * @param ctx
   * @return
   */
  public QLTree visitCompQuestion(QL4Parser.CompQuestionContext ctx) {
	  if (verbose) 
		  System.out.println("Visiting CompQuestion");
	  
	  QLTree id = ctx.IDENTIFIER().accept(this);
	  QLTree label = ctx.LABEL().accept(this);
	  QLTree type = ctx.TYPE().accept(this);
	  QLTree value = ctx.expression().accept(this);
	  
	  return new QL4CompQuestion(id, label, type, value); 
  }
}
