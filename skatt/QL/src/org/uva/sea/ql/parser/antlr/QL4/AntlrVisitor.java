package org.uva.sea.ql.parser.antlr.QL4;

import java.util.ArrayList;
import java.util.List;

import org.uva.sea.ql.parser.antlr.QL4.AST.Conditional;
import org.uva.sea.ql.parser.antlr.QL4.AST.Form;
import org.uva.sea.ql.parser.antlr.QL4.AST.Question;
import org.uva.sea.ql.parser.antlr.QL4.AST.QL4Structures;
import org.uva.sea.ql.parser.antlr.QL4.AST.QL4Tree;
import org.uva.sea.ql.parser.antlr.QL4.AST.Expression.BraceExpr;
import org.uva.sea.ql.parser.antlr.QL4.AST.Expression.Binary.AndExpr;
import org.uva.sea.ql.parser.antlr.QL4.AST.Expression.Binary.DivExpr;
import org.uva.sea.ql.parser.antlr.QL4.AST.Expression.Binary.EqExpr;
import org.uva.sea.ql.parser.antlr.QL4.AST.Expression.Binary.GeqExpr;
import org.uva.sea.ql.parser.antlr.QL4.AST.Expression.Binary.MinExpr;
import org.uva.sea.ql.parser.antlr.QL4.AST.Expression.Binary.MultExpr;
import org.uva.sea.ql.parser.antlr.QL4.AST.Expression.Binary.NeqExpr;
import org.uva.sea.ql.parser.antlr.QL4.AST.Expression.Binary.OrExpr;
import org.uva.sea.ql.parser.antlr.QL4.AST.Expression.Binary.PlusExpr;
import org.uva.sea.ql.parser.antlr.QL4.AST.Value.QL4Bool;
import org.uva.sea.ql.parser.antlr.QL4.AST.Value.QL4Identifier;
import org.uva.sea.ql.parser.antlr.QL4.AST.Value.QL4Label;
import org.uva.sea.ql.parser.antlr.QL4.AST.Value.QL4Type;

import QL4.QL4BaseVisitor;
import QL4.QL4Parser;

/**
 * A visitor for the QL4 grammar. Visits a tree parsed by the Antlr4
 * generated QL4parser on the QL4 grammar. Extends the QL4BaseVisitor
 * generated by Antrl4 and implements any function that needs
 * a more sophisticated visit  than depth first
 * @author Sammie Katt
 *
 */
public class AntlrVisitor extends QL4BaseVisitor<QL4Tree> {

  /**
   * Specifies behavior when visiting the form 
   * it will simply visit its structures and return the tree
   * generated throughout the visiting process
   */
  public Form visitForm(QL4Parser.FormContext ctx) {
	  return new Form(ctx.structures().accept(this));
  }
  
  /**
   * Returns a structures object, containing its structure in a list
   */
  public QL4Tree visitStructures(QL4Parser.StructuresContext ctx) {
	  List<QL4Tree> structures = new ArrayList<QL4Tree>();

	  for (QL4Parser.StructureContext struct : ctx.structure()) {
		  structures.add(struct.accept(this));
	  }
	  
	  return new QL4Structures(structures);
  }

  /**
   * Returns a conditional object containing the expressions
   * and structures of the if/elseif/else in the context
   */
  public Conditional visitConditional(QL4Parser.ConditionalContext ctx) {

	 // define if/else (if available) conditions and structures
	 QL4Tree ifExpr = ctx.ifexpr.accept(this);
	 QL4Tree ifStruc = ctx.ifstruc.accept(this);
	 
	 QL4Tree elseStruc = null;
	 if (ctx.elsestruc != null) {
		 elseStruc = ctx.elsestruc.accept(this);
	 } 
	 
	 // define elseifConditions and their structs by looping over them in ctx
	 List<QL4Tree> elseifExprs = new ArrayList<QL4Tree>();
	 List<QL4Tree> elseifStrucs = new ArrayList<QL4Tree>();

	 // start i = 1, as first expression is always if
	 for (int i=1; i < ctx.expression().size(); i++) {
		 elseifExprs.add(ctx.expression(i).accept(this));
		 elseifStrucs.add(ctx.structures(i).accept(this));
	 }
	 
	 return new Conditional(ifExpr, elseifExprs, 
			 ifStruc, elseifStrucs, elseStruc);
  }
  
  /**
   * Returns a question object, containing its content:
   * Type, label, id and value (question.computed is false)
   */
  public Question visitRegQuestion(QL4Parser.RegQuestionContext ctx) {
	  QL4Tree id = new QL4Identifier(ctx.IDENTIFIER().getText());
	  QL4Tree label = new QL4Label(ctx.LABEL().getText());
	  QL4Tree type = new QL4Type(ctx.TYPE().getText());
	  
	  return new Question(id, label, type); 
  }
  

  /**
   * Returns a Question object, containing its content:
   * Type, label, id and value (question.computed is true)
   */
  public Question visitCompQuestion(QL4Parser.CompQuestionContext ctx) {
	  QL4Tree id = new QL4Identifier(ctx.IDENTIFIER().getText());
	  QL4Tree label = new QL4Label(ctx.LABEL().getText());
	  QL4Tree type = new QL4Type(ctx.TYPE().getText());
	  QL4Tree value = ctx.expression().accept(this);
	  
	  return new Question(id, label, type, value); 
  }

  //////////////////////// visiting binair math expressions
  public BraceExpr visitBraceExpr(QL4Parser.BraceExprContext ctx) {
	  return new BraceExpr(ctx.expression().accept(this));
  }
  
  public MultExpr visitMultExpr(QL4Parser.MultExprContext ctx) {
	  QL4Tree lhs = ctx.lhs.accept(this);
	  QL4Tree rhs = ctx.rhs.accept(this);
	  
	  return new MultExpr(lhs, rhs);	  
  }
  
  public DivExpr visitDivExpr(QL4Parser.DivExprContext ctx) {
	  QL4Tree lhs = ctx.lhs.accept(this);
	  QL4Tree rhs = ctx.rhs.accept(this);
	  
	  return new DivExpr(lhs, rhs);	  
  }
  
  public PlusExpr visitPlusExpr(QL4Parser.PlusExprContext ctx) {
	  QL4Tree lhs = ctx.lhs.accept(this);
	  QL4Tree rhs = ctx.rhs.accept(this);
	  
	  return new PlusExpr(lhs, rhs);	  
  }
  
  public MinExpr visitMinExpr(QL4Parser.MinExprContext ctx) {
	  QL4Tree lhs = ctx.lhs.accept(this);
	  QL4Tree rhs = ctx.rhs.accept(this);
	  
	  return new MinExpr(lhs, rhs);	  
  }
  
  //////////////////////// visiting binair logical expressions

  public AndExpr visitAndExpr(QL4Parser.AndExprContext ctx) {
	  QL4Tree lhs = ctx.lhs.accept(this);
	  QL4Tree rhs = ctx.rhs.accept(this);
	  
	  return new AndExpr(lhs, rhs);	  
  }
  
  public OrExpr visitOrExpr(QL4Parser.OrExprContext ctx) {
	  QL4Tree lhs = ctx.lhs.accept(this);
	  QL4Tree rhs = ctx.rhs.accept(this);
	  
	  return new OrExpr(lhs, rhs);	  
  }
  
  public EqExpr visitEqExpr(QL4Parser.EqExprContext ctx) {
	  QL4Tree lhs = ctx.lhs.accept(this);
	  QL4Tree rhs = ctx.rhs.accept(this);
	  
	  return new EqExpr(lhs, rhs);	  
  }
  
  public NeqExpr visitNeqExpr(QL4Parser.NeqExprContext ctx) {
	  QL4Tree lhs = ctx.lhs.accept(this);
	  QL4Tree rhs = ctx.rhs.accept(this);
	  
	  return new NeqExpr(lhs, rhs);	  
  }
  
  public GeqExpr visitGeqExpr(QL4Parser.GeqExprContext ctx) {
	  QL4Tree lhs = ctx.lhs.accept(this);
	  QL4Tree rhs = ctx.rhs.accept(this);
	  
	  return new GeqExpr(lhs, rhs);	  
  }
  
  //////////////////////// visiting QL4 primitives (bool, string etc)
  
  public QL4Bool visitBool(QL4Parser.BoolContext ctx) {
	  return new QL4Bool(ctx.getText());
  }
}
